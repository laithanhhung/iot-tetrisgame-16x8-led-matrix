#include <SoftwareSerial.h>

// Khai báo cổng Serial cho ESP8266
SoftwareSerial mySerial(9, 13);  // RX, TX của Arduino


#include <LedControl.h>

LedControl lc = LedControl(12, 11, 10, 4); // (dataPin, clockPin, csPin, totalDevices)

int lc0[] = {0, 0, 0, 0, 0, 0, 0, 0};
int lc1[] = {0, 0, 0, 0, 0, 0, 0, 0};
long active[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
long screen[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
int tmpCol = 0;


int figura = 0;
int figuraNext = 0;
int fromLeft = 0;
int fromRight = 0;
int angle = 0;
int colCheck = 0;
int moveCheck = 0;
int score = 0;
int started = 0;
int lcRows = 16;
int lcCols = 8;
int allLines = 0;
int currLines = 0;
int brickDelay = 0;
int defDelay = 500;
int level = 0;
int statusScore = 0;// để truyền điểm


boolean sound = true;
//Pinos
int speaker_pin   = 2;
int start_button  = 3;
int sound_button  = 4;
int left_button   = 8;
int down_button   = 6;
int rotate_button = 7;
int right_button  = 5;

//Điểm số
byte one[3][8] =
{
  {0, 0, 0, 0, 0, 0, 0, 1},
  {1, 1, 1, 1, 1, 1, 1, 1},
  {0, 1, 0, 0, 0, 0, 0, 1},
};

byte two[3][8] =
{
  {0, 1, 1, 1, 0, 0, 1, 1},
  {1, 0, 0, 0, 1, 0, 0, 1},
  {0, 1, 1, 0, 0, 1, 1, 1},
};

byte three[3][8] =
{
  {0, 1, 1, 1, 0, 1, 1, 1},
  {1, 0, 0, 0, 1, 0, 0, 1},
  {0, 1, 1, 0, 0, 0, 1, 1},
};

byte four[3][8] =
{
  {1, 1, 1, 1, 1, 1, 1, 1},
  {0, 0, 0, 0, 1, 0, 0, 0},
  {1, 1, 1, 1, 1, 0, 0, 0},
};

byte five[3][8] =
{
  {0, 1, 1, 0, 0, 1, 1, 1},
  {1, 0, 0, 0, 1, 0, 0, 1},
  {0, 1, 1, 1, 0, 0, 1, 1},
};

byte six[3][8] =
{
  {0, 1, 1, 0, 1, 1, 1, 1},
  {1, 0, 0, 0, 1, 0, 0, 1},
  {0, 1, 1, 1, 1, 1, 1, 1},
};

byte seven[3][8] =
{
  {1, 1, 1, 1, 1, 1, 1, 1},
  {1, 0, 0, 0, 1, 0, 0, 0},
  {1, 0, 0, 0, 0, 0, 0, 0},
};

byte eight[3][8] =
{
  {0, 1, 1, 0, 1, 1, 1, 1},
  {1, 0, 0, 1, 1, 0, 0, 1},
  {0, 1, 1, 0, 1, 1, 1, 1},
};

byte nine[3][8] =
{
  {0, 1, 1, 1, 1, 1, 1, 1},
  {1, 0, 0, 0, 1, 0, 0, 1},
  {0, 1, 1, 1, 1, 0, 1, 1},
};

byte zero[3][8] =
{
  {0, 1, 1, 1, 1, 1, 1, 0},
  {1, 0, 0, 0, 0, 0, 0, 1},
  {0, 1, 1, 1, 1, 1, 1, 0},
};
//Điểm số

//Nuty
int length = 99;
char notes[] = "EbCDCbaaCEDCbbCDECaa DFAGFEECEDCbbCDECaa EbCDCbaaCEDCbbCDECaa DFAGFEECEDCbbCDECaa ECDbCab ECDbCEAJ ";
int beats[] =      // Som
{
  2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 2, 2, 4, 2,
  2, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 2, 2, 4, 1,
  2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 2, 2, 4, 2,
  2, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 2, 2, 4, 1,
  5, 5, 5, 5, 5, 5, 7, 2, 5, 5, 5, 5, 2, 2, 5, 5, 3
};
int tempo = 128;        // Tempo


void playTone(int tone, int duration) {
  for (long i = 0; i < duration * 1000L; i += tone * 2) {
    digitalWrite(speaker_pin, HIGH);
    delayMicroseconds(tone);
    digitalWrite(speaker_pin, LOW);
    delayMicroseconds(tone);
  }
}


void playNote(char note, int duration) {
  char names[] = { 'c', 'd', 'e', 'f', 'g', 'a', 'b', 'C' , 'D', 'E', 'F', 'G', 'J', 'A', 'B'};
  int tones[] = { 1915, 1700, 1519, 1432, 1275, 1136, 1014, 956, 850, 760, 716, 637, 603, 568, 507 };

  for (int i = 0; i < 14; i++) {
    if (names[i] == note) {
      playTone(tones[i], duration);
    }
  }
}


void updateColumn(int colnum)
{
  lc0[colnum] = active[colnum] >> (lcRows / 2);
  lc1[colnum] = active[colnum];
  lc.setRow(0, colnum, screen[colnum] | lc1[colnum]);
  lc.setRow(1, colnum, (screen[colnum] >> (lcRows / 2)) | lc0[colnum]);
}



void buttonDelay(int bdelay)
{
  if (brickDelay > bdelay)
  {
    brickDelay -= bdelay;
  }
  delay(bdelay);
}

byte figuraO[] =
{
  B01111111,
  B01000001,
  B01000001,
  B01011001,
  B01011001,
  B01000001,
  B01000001,
  B01111111
};
byte figuraL[] =
{
  B01111111,
  B01000001,
  B01000001,
  B01011101,
  B01000101,
  B01000001,
  B01000001,
  B01111111
};
byte figuraJ[] =
{
  B01111111,
  B01000001,
  B01000001,
  B01000101,
  B01011101,
  B01000001,
  B01000001,
  B01111111
};
byte figuraT[] =
{
  B01111111,
  B01000001,
  B01000001,
  B01010001,
  B01011001,
  B01010001,
  B01000001,
  B01111111
};
byte figuraS[] =
{
  B01111111,
  B01000001,
  B01000001,
  B01011001,
  B01001101,
  B01000001,
  B01000001,
  B01111111
};
byte figuraZ[] =
{
  B01111111,
  B01000001,
  B01000001,
  B01001101,
  B01011001,
  B01000001,
  B01000001,
  B01111111
};
byte figuraI[] =
{
  B01111111,
  B01000001,
  B01001001,
  B01001001,
  B01001001,
  B01001001,
  B01000001,
  B01111111
};

void splashScreen()
{
  int one[] =
  {
    B11100100,
    B01001010,
    B01001000,
    B01000100,
    B01001000,
    B01001010,
    B01000100,
    B00000000
  };

  int two[] =
  {
    B11100100,
    B01001010,
    B01001010,
    B01001100,
    B01001010,
    B01001010,
    B01001010,
    B00000000
  };
  int three[] =
  {
    B10010000,
    B00101000,
    B10100001,
    B10010001,
    B10001001,
    B10101001,
    B10010000,
    B00000000
  };

  int four[] =
  {
    B01111000,
    B10000110,
    B10000110,
    B10000000,
    B10001111,
    B10000110,
    B10000110,
    B01111100
  };

  for (int rownum = 0; rownum < 8; rownum++)
  {
    lc.setRow(3, rownum, one[rownum]);
    lc.setRow(2, rownum, two[rownum]);
    lc.setRow(1, rownum, three[rownum]);
    lc.setRow(0, rownum, four[rownum]);
  }
}

void winner()
{
  int one[] =
  {
    B01000000,
    B01000000,
    B01100000,
    B00100000,
    B00110001,
    B00010101,
    B00010101,
    B00001010
  };

  int two[] =
  {
    B01011101,
    B01001001,
    B11001001,
    B10001001,
    B10001001,
    B00001001,
    B00001001,
    B00011101
  };
  int three[] =
  {
    B11011101,
    B01010101,
    B01010101,
    B01010101,
    B01010101,
    B01010101,
    B01010101,
    B01010101
  };

  int four[] =
  {
    B11011100,
    B00010010,
    B00010010,
    B00010100,
    B10011000,
    B00010100,
    B00010010,
    B11010010
  };

  for (int rownum = 0; rownum < 8; rownum++)
  {
    lc.setRow(3, rownum, one[rownum]);
    lc.setRow(2, rownum, two[rownum]);
    lc.setRow(1, rownum, three[rownum]);
    lc.setRow(0, rownum, four[rownum]);
  }
  sendScore(score);
  delay(2000);
}

void setup() {
  pinMode(speaker_pin,  OUTPUT);
  pinMode(rotate_button, INPUT_PULLUP);
  pinMode(down_button,  INPUT_PULLUP);
  pinMode(right_button, INPUT_PULLUP);
  pinMode(left_button,  INPUT_PULLUP);
  pinMode(start_button, INPUT_PULLUP);
  pinMode(sound_button, INPUT_PULLUP);

  lc.shutdown(0, false);
  lc.shutdown(1, false);
  lc.shutdown(2, false);
  lc.shutdown(3, false);

  lc.setIntensity(0, 5);
  lc.setIntensity(1, 5);
  lc.setIntensity(2, 5);
  lc.setIntensity(3, 5);

  lc.clearDisplay(0);
  lc.clearDisplay(1);
  lc.clearDisplay(2);
  lc.clearDisplay(3);
  Serial.begin(9600);
  mySerial.begin(9600);
  randomSeed(analogRead(0));
}


//LOOP
void loop()
{
  if (started == 0)
  {
    splashScreen();

    for (int i = 0; i < length; i++)
    {

      if (digitalRead(sound_button) == LOW)
      {
        sound = ! sound;
        delay(300);
      }

      if (digitalRead(start_button) == LOW)
      {
        started = 1;
        break;
      }
      if (notes[i] == ' ')
      {
        delay(beats[i] * tempo);   //Pausa
      }
      else
      {
        if (sound == 1) {
          playNote(notes[i], beats[i] * tempo);
        }
        else
        {
          digitalWrite(speaker_pin, LOW);
        }
      }


      delay(tempo / 2);
    }
  }



  else
  {

    lc.clearDisplay(0);
    lc.clearDisplay(1);
    lc.clearDisplay(2);
    lc.clearDisplay(3);
    memset(lc0, 0, sizeof(lc0));
    memset(lc1, 0, sizeof(lc1));
    memset(active, 0, sizeof(active));
    memset(screen, 0, sizeof(screen));
    tmpCol = 0;

    while (started == 1)
    {

      if (allLines < 30)
      {
        level = 0;              //Level 0
      }
      else if (allLines < 50)
      {
        level = 1;              //Level 1
      }
      else if (allLines < 70)
      {
        level = 2;              //Level 2
      }
      else if (allLines < 80)
      {
        level = 3;              //Level 3
      }
      else if (allLines < 90)
      {
        level = 4;              //Level 4
      } else {
        level = 5;
      }
      if (allLines > 99)
      {
        winner();
        if (digitalRead(start_button) == LOW)
        {
          memset(lc0, 0, sizeof(lc0));
          memset(lc1, 0, sizeof(lc1));
          memset(active, 0, sizeof(active));
          memset(screen, 0, sizeof(screen));
          score = 0;
          allLines = 0;
          figura = 0;
          started = 0;
          break;
        }
      } else {




        defDelay = (5 - level) * 100;
        brickDelay = defDelay;


        if (figura == 0)
        {
          figura = random(1, 8);
        }
        else
        {
          figura = figuraNext;
        }
        figuraNext = random(1, 8);
        angle = 0;



        switch (figura)
        {
          case 1:
            //"O"
            active[3] = 131072 + 65536;
            active[4] = 131072 + 65536;
            fromLeft = 3;
            fromRight = 3;
            break;

          case 2:
            //"L"
            active[3] = 262144 + 131072 + 65536;
            active[4] = 65536;
            fromLeft = 3;
            fromRight = 3;
            break;

          case 3:
            //"J"
            active[3] = 65536;
            active[4] = 262144 + 131072 + 65536;
            fromLeft = 3;
            fromRight = 3;
            break;

          case 4:
            //"T"
            active[2] = 131072;
            active[3] = 131072 + 65536;
            active[4] = 131072;
            fromLeft = 2;
            fromRight = 3;
            break;

          case 5:
            //"I"
            active[3] = 524288 + 262144 + 131072 + 65536;
            fromLeft = 3;
            fromRight = 4;
            break;

          case 6:
            //"Z"
            active[2] = 131072;
            active[3] = 131072 + 65536;
            active[4] = 65536;
            fromLeft = 2;
            fromRight = 3;
            break;

          case 7:
            //"S"
            active[2] = 65536;
            active[3] = 131072 + 65536;
            active[4] = 131072;
            fromLeft = 2;
            fromRight = 3;
            break;
        }

        for (int krok = 0; krok < lcRows + 1; krok++)
        {
          colCheck = 0;


          for (int i = 0; i < (lcCols / 2); i++)
          {
            if ((digitalRead(left_button) == LOW) && (fromLeft > 0))
            {
              moveCheck = 0;
              for (int colnum = fromLeft; colnum < (lcCols - fromRight); colnum++)
              {
                if ((active[colnum] & screen[colnum - 1]) == 0)
                {
                  moveCheck++;
                }
              }

              if (moveCheck == (lcCols - fromLeft - fromRight))
              {
                for (int colnum = (fromLeft - 1); colnum < (lcCols - fromRight); colnum++)
                {
                  if (colnum < (lcCols - 1))
                  {
                    active[colnum] = active[colnum + 1];
                  }
                  else
                  {
                    active[colnum] = 0;
                  }
                  updateColumn(colnum);
                }
                fromLeft--;
                fromRight++;
                playNote('E', 10);
                buttonDelay(200);
              }
            }
          }





          for (int i = 0; i < (lcCols / 2); i++)
          {
            if ((digitalRead(right_button) == LOW) && (fromRight > 0))
            {
              moveCheck = 0;
              for (int colnum = fromLeft; colnum < (lcCols - fromRight); colnum++)
              {
                if ((active[colnum] & screen[colnum + 1]) == 0)
                {
                  moveCheck++;
                }
              }

              if (moveCheck == (lcCols - fromLeft - fromRight))
              {
                for (int colnum = (lcCols - fromRight); colnum > (fromLeft - 1); colnum--)
                {
                  if (colnum > 0)
                  {
                    active[colnum] = active[colnum - 1];
                  }
                  else
                  {
                    active[colnum] = 0;
                  }
                  updateColumn(colnum);
                }
                fromLeft++;
                fromRight--;
                playNote('E', 10);
                buttonDelay(200);
              }
            }
          }

          if (digitalRead(down_button) == LOW)
          {
            brickDelay = 0;
            playNote('b', 10);
          }
          else
          {
            brickDelay = defDelay;
          }



          for (int i = 0; i < (lcCols / 2); i++)
          {
            if (digitalRead(rotate_button) == LOW)
            {

              switch (figura)
              {
                case 1:
                  //"O"
                  break;

                case 2:
                  //"L"
                  switch (angle)
                  {
                    case 0:
                      // . o .        . . .
                      // . o .  --->  o o o
                      // . o o        o . .
                      if ((fromLeft > 0)
                          && (((active[fromLeft + 1] | (active[fromLeft + 1] << 1)) & screen[fromLeft - 1]) == 0))
                      {
                        active[fromLeft - 1] = (active[fromLeft + 1] | (active[fromLeft + 1] << 1));
                        updateColumn(fromLeft - 1);
                        active[fromLeft] = (active[fromLeft + 1] << 1);
                        updateColumn(fromLeft);
                        active[fromLeft + 1] = (active[fromLeft + 1] << 1);
                        updateColumn(fromLeft + 1);
                        fromLeft--;
                        angle = 1;
                      }
                      break;

                    case 1:
                      // . . .        o o .
                      // o o o  --->  . o .
                      // o . .        . o .
                      if ((((active[fromLeft + 2] << 1) & screen[fromLeft]) == 0)
                          && ((((active[fromLeft + 1] << 1) | (active[fromLeft + 1] >> 1)) & screen[fromLeft + 1]) == 0))
                      {
                        active[fromLeft] = (active[fromLeft + 2] << 1);
                        updateColumn(fromLeft);
                        active[fromLeft + 1] = active[fromLeft + 1] | (active[fromLeft + 1] << 1) | (active[fromLeft + 1] >> 1);
                        updateColumn(fromLeft + 1);
                        active[fromLeft + 2] = 0;
                        updateColumn(fromLeft + 2);
                        fromRight++;
                        angle = 2;
                      }
                      break;

                    case 2:
                      // o o .        . . o
                      // . o .  --->  o o o
                      // . o .        . . .
                      if ((fromRight > 0)
                          && (((active[fromLeft] >> 1) & screen[fromLeft]) == 0)
                          && ((((active[fromLeft + 1] << 1) & active[fromLeft + 1]) & screen[fromLeft + 1]) == 0))
                      {
                        active[fromLeft] = (active[fromLeft] >> 1);
                        updateColumn(fromLeft);
                        active[fromLeft + 1] = active[fromLeft];
                        updateColumn(fromLeft + 1);
                        active[fromLeft + 2] = ((active[fromLeft + 1] << 1) | active[fromLeft + 1]);
                        updateColumn(fromLeft + 2);
                        fromRight--;
                        krok--;
                        angle = 3;
                      }
                      break;

                    case 3:
                      // . . o        . o .
                      // o o o  --->  . o .
                      // . . .        . o o
                      if (((((active[fromLeft] << 1) | (active[fromLeft] >> 1)) & screen[fromLeft + 1]) == 0)
                          && (((active[fromLeft] >> 1) & screen[fromLeft + 2]) == 0)
                          && (krok < lcRows))
                      {
                        active[fromLeft] = 0;
                        updateColumn(fromLeft);
                        active[fromLeft + 1] = (active[fromLeft + 2] | (active[fromLeft + 2] >> 1));
                        updateColumn(fromLeft + 1);
                        active[fromLeft + 2] = ((active[fromLeft + 2] >> 1) & (active[fromLeft + 2] >> 2));
                        updateColumn(fromLeft + 2);
                        fromLeft++;
                        krok++;
                        angle = 0;
                      }
                      break;
                  }
                  break;

                case 3:
                  //"J"
                  switch (angle)
                  {
                    case 0:
                      // . o .        o . .
                      // . o .  --->  o o o
                      // o o .        . . .
                      if ((fromRight > 0)
                          && ((((active[fromLeft] << 2) | (active[fromLeft] << 1)) & screen[fromLeft]) == 0)
                          && (((active[fromLeft] << 1) & screen[fromLeft + 2]) == 0))
                      {
                        active[fromLeft] = ((active[fromLeft] << 2) | (active[fromLeft] << 1));
                        updateColumn(fromLeft);
                        active[fromLeft + 1] = ((active[fromLeft + 1] << 1) & (active[fromLeft + 1] >> 1));
                        updateColumn(fromLeft + 1);
                        active[fromLeft + 2] = active[fromLeft + 1];
                        updateColumn(fromLeft + 2);
                        fromRight--;
                        krok--;
                        angle = 1;
                      }
                      break;

                    case 1:
                      // o . .        . o o
                      // o o o  --->  . o .
                      // . . .        . o .
                      if ((krok < lcRows)
                          && ((((active[fromLeft + 1] << 1) | (active[fromLeft + 1] >> 1)) & screen[fromLeft + 1]) == 0)
                          && (((active[fromLeft + 2] << 1) & screen[fromLeft + 2]) == 0))
                      {
                        active[fromLeft] = 0;
                        updateColumn(fromLeft);
                        active[fromLeft + 1] = (active[fromLeft + 1] | (active[fromLeft + 1] << 1) | (active[fromLeft + 1] >> 1));
                        updateColumn(fromLeft + 1);
                        active[fromLeft + 2] = (active[fromLeft + 2] << 1);
                        updateColumn(fromLeft + 2);
                        fromLeft++;
                        krok++;
                        angle = 2;
                      }
                      break;

                    case 2:
                      // . o o        . . .
                      // . o .  --->  o o o
                      // . o .        . . o
                      if ((fromLeft > 0)
                          && (((active[fromLeft + 1] >> 1) & screen[fromLeft - 1]) == 0)
                          && ((((active[fromLeft + 1] >> 1) | (active[fromLeft + 1] >> 2)) & screen[fromLeft + 1]) == 0))
                      {
                        active[fromLeft - 1] = (active[fromLeft + 1] >> 1);
                        updateColumn(fromLeft - 1);
                        active[fromLeft] = active[fromLeft - 1];
                        updateColumn(fromLeft);
                        active[fromLeft + 1] = (active[fromLeft] | (active[fromLeft + 1] >> 2));
                        updateColumn(fromLeft + 1);
                        fromLeft--;
                        angle = 3;
                      }
                      break;

                    case 3:
                      // . . .        . o .
                      // o o o  --->  . o .
                      // . . o        o o .
                      if ((((active[fromLeft] >> 1) & screen[fromLeft]) == 0)
                          && ((((active[fromLeft] << 1) | (active[fromLeft >> 1])) & screen[fromLeft + 1]) == 0))
                      {
                        active[fromLeft] = (active[fromLeft] >> 1);
                        updateColumn(fromLeft);
                        active[fromLeft + 1] = ((active[fromLeft + 1] << 1) | active[fromLeft + 2]);
                        updateColumn(fromLeft + 1);
                        active[fromLeft + 2] = 0;
                        updateColumn(fromLeft + 2);
                        fromRight++;
                        angle = 0;
                      }
                      break;
                  }
                  break;

                case 4:
                  //"T"
                  switch (angle)
                  {
                    case 0:
                      // . . .        . o .
                      // o o o  --->  o o .
                      // . o .        . o .
                      if (((active[fromLeft + 1] << 1) & screen[fromLeft + 1]) == 0)
                      {
                        //active[fromLeft]
                        active[fromLeft + 1] = active[fromLeft + 1] | (active[fromLeft + 1] << 1);
                        updateColumn(fromLeft + 1);
                        active[fromLeft + 2] = 0;
                        updateColumn(fromLeft + 2);
                        fromRight++;
                        angle = 1;
                      }
                      break;

                    case 1:
                      // . o .        . o .
                      // o o .  --->  o o o
                      // . o .        . . .
                      if ((fromRight > 0)
                          && ((active[fromLeft] & screen[fromLeft + 2]) == 0))
                      {
                        //active[fromLeft]
                        active[fromLeft + 1] = active[fromLeft + 1] & (active[fromLeft + 1] << 1);
                        updateColumn(fromLeft + 1);
                        active[fromLeft + 2] = active[fromLeft];
                        updateColumn(fromLeft + 2);
                        fromRight--;
                        krok--;
                        angle = 2;
                      }
                      break;

                    case 2:
                      // . o .        . o .
                      // o o o  --->  . o o
                      // . . .        . o .
                      if ((((active[fromLeft + 1] >> 1) & screen[fromLeft + 1]) == 0)
                          && (krok < lcRows))
                      {
                        active[fromLeft] = 0;
                        updateColumn(fromLeft);
                        active[fromLeft + 1] = active[fromLeft + 1] | (active[fromLeft + 1] >> 1);
                        updateColumn(fromLeft + 1);
                        //active[fromLeft + 2]
                        fromLeft++;
                        krok++;
                        angle = 3;
                      }
                      break;

                    case 3:
                      if ((fromLeft > 0)
                          && ((active[fromLeft + 1] & screen[fromLeft - 1]) == 0))
                      {
                        active[fromLeft - 1] = active[fromLeft + 1];
                        updateColumn(fromLeft - 1);
                        active[fromLeft] = active[fromLeft] & (active[fromLeft] >> 1);
                        updateColumn(fromLeft);
                        fromLeft--;
                        angle = 0;
                      }
                      break;
                  }
                  break;

                case 5:
                  //"I"
                  switch (angle)
                  {
                    case 0:
                      // . o . .        . . . .
                      // . o . .  --->  o o o o
                      // . o . .        . . . .
                      // . o . .        . . . .
                      if ((fromLeft > 0)
                          && (fromRight > 1)

                          && ((((((active[fromLeft] >> 1) & (active[fromLeft] << 2)) & screen[fromLeft - 1]) & screen[fromLeft + 1]) & screen[fromLeft + 2]) == 0))
                      {
                        active[fromLeft - 1] = ((active[fromLeft] >> 1) & (active[fromLeft] << 2));
                        updateColumn(fromLeft - 1);
                        active[fromLeft] = active[fromLeft - 1];
                        updateColumn(fromLeft);
                        active[fromLeft + 1] = active[fromLeft];
                        updateColumn(fromLeft + 1);
                        active[fromLeft + 2] = active[fromLeft];
                        updateColumn(fromLeft + 2);
                        fromLeft--;
                        fromRight -= 2;
                        krok -= 2;
                        angle = 1;
                      }
                      break;

                    case 1:
                      // . . . .        . . o .
                      // o o o o  --->  . . o .
                      // . . . .        . . o .
                      // . . . .        . . o .
                      if ((krok < (lcRows - 1))
                          && (((active[fromLeft] << 1) | (active[fromLeft] >> 1) | (active[fromLeft] >> 2)) & screen[fromLeft + 2]) == 0)
                      {
                        active[fromLeft] = 0;
                        updateColumn(fromLeft);
                        active[fromLeft + 1] = 0;
                        updateColumn(fromLeft + 1);

                        active[fromLeft + 2] = (active[fromLeft + 2] | (active[fromLeft + 2] << 1) | (active[fromLeft + 2] >> 1) | (active[fromLeft + 2] >> 2));
                        updateColumn(fromLeft + 2);
                        active[fromLeft + 3] = 0;
                        updateColumn(fromLeft + 3);
                        fromLeft += 2;
                        fromRight++;
                        krok += 2;
                        angle = 2;
                      }
                      break;

                    case 2:
                      // . . o .        . . . .
                      // . . o .  --->  . . . .
                      // . . o .        o o o o
                      // . . o .        . . . .
                      if ((fromLeft > 1)
                          && (fromRight > 0)

                          && ((((((active[fromLeft] << 1) & (active[fromLeft] >> 2)) & screen[fromLeft - 2]) & screen[fromLeft - 1]) & screen[fromLeft + 1]) == 0))
                      {
                        active[fromLeft - 2] = ((active[fromLeft] << 1) & (active[fromLeft] >> 2));
                        updateColumn(fromLeft - 2);
                        active[fromLeft - 1] = active[fromLeft - 2];
                        updateColumn(fromLeft - 1);
                        active[fromLeft] = active[fromLeft - 1];
                        updateColumn(fromLeft);
                        active[fromLeft + 1] = active[fromLeft];
                        updateColumn(fromLeft + 1);
                        fromLeft -= 2;
                        fromRight--;
                        krok--;
                        angle = 3;
                      }
                      break;

                    case 3:
                      // . . . .        . o . .
                      // . . . .  --->  . o . .
                      // o o o o        . o . .
                      // . . . .        . o . .
                      if ((krok < (lcRows))
                          && (((active[fromLeft] >> 1) | (active[fromLeft] << 1) | (active[fromLeft] << 2)) & screen[fromLeft + 1]) == 0)
                      {
                        active[fromLeft] = 0;
                        updateColumn(fromLeft);

                        active[fromLeft + 1] = (active[fromLeft + 1] | (active[fromLeft + 1] >> 1) | (active[fromLeft + 1] << 1) | (active[fromLeft + 1] << 2));
                        updateColumn(fromLeft + 1);
                        active[fromLeft + 2] = 0;
                        updateColumn(fromLeft + 2);
                        active[fromLeft + 3] = 0;
                        updateColumn(fromLeft + 3);
                        fromLeft++;
                        fromRight += 2;
                        krok++;
                        angle = 0;
                      }
                      break;
                  }
                  break;

                case 6:
                  //"Z"
                  switch (angle)
                  {
                    case 0:
                      // . . .        . o .
                      // o o .  --->  o o .
                      // . o o        o . .
                      if (((active[fromLeft + 1] & screen[fromLeft]) == 0)
                          && (((active[fromLeft + 1] << 1) & screen[fromLeft + 1]) == 0))
                      {
                        active[fromLeft] = active[fromLeft + 1];
                        updateColumn(fromLeft);
                        active[fromLeft + 1] = (active[fromLeft + 1] << 1);
                        updateColumn(fromLeft + 1);
                        active[fromLeft + 2] = 0;
                        updateColumn(fromLeft + 2);
                        fromRight++;
                        angle = 1;
                      }
                      break;

                    case 1:
                      // . o .        o o .
                      // o o .  --->  . o o
                      // o . .        . . .
                      if ((fromRight > 0)
                          && ((((active[fromLeft] << 2) & (active[fromLeft] << 1)) & screen[fromLeft]) == 0)
                          && (((active[fromLeft] & active[fromLeft + 1]) & screen[fromLeft + 2]) == 0))
                      {
                        active[fromLeft] = ((active[fromLeft] << 2) & (active[fromLeft] << 1));
                        updateColumn(fromLeft);
                        //active[fromLeft + 1]
                        active[fromLeft + 2] = (active[fromLeft] >> 1);
                        updateColumn(fromLeft + 2);
                        fromRight--;
                        krok--;
                        angle = 2;
                      }
                      break;

                    case 2:
                      // o o .        . . o
                      // . o o  --->  . o o
                      // . . .        . o .
                      if ((krok < lcRows)
                          && (((active[fromLeft + 1] >> 1) & screen[fromLeft + 1]) == 0)
                          && (((active[fromLeft + 2] << 1) & screen[fromLeft + 2]) == 0))
                      {
                        active[fromLeft] = 0;
                        updateColumn(fromLeft);
                        active[fromLeft + 1] = (active[fromLeft + 1] >> 1);
                        updateColumn(fromLeft + 1);
                        active[fromLeft + 2] = (active[fromLeft + 2] | (active[fromLeft + 2] << 1));
                        updateColumn(fromLeft + 2);
                        fromLeft++;
                        krok++;
                        angle = 3;
                      }
                      break;

                    case 3:
                      // . . o        . . .
                      // . o o  --->  o o .
                      // . o .        . o o
                      if ((fromLeft > 0)
                          && (((active[fromLeft] & active[fromLeft + 1]) & screen[fromLeft - 1]) == 0)
                          && (((active[fromLeft + 1] >> 1) & screen[fromLeft + 1]) == 0))
                      {
                        active[fromLeft - 1] = (active[fromLeft] & active[fromLeft + 1]);
                        updateColumn(fromLeft - 1);
                        //active[fromLeft]
                        active[fromLeft + 1] = (active[fromLeft - 1] >> 1);
                        updateColumn(fromLeft + 1);
                        fromLeft--;
                        angle = 0;
                      }
                      break;
                  }
                  break;

                case 7:
                  //"S"
                  switch (angle)
                  {
                    case 0:
                      // . . .        o . .
                      // . o o  --->  o o .
                      // o o .        . o .
                      if (((active[fromLeft + 1] << 1) & screen[fromLeft]) == 0)
                      {
                        active[fromLeft] = (active[fromLeft + 1] << 1);
                        updateColumn(fromLeft);
                        //active[fromLeft + 1]
                        active[fromLeft + 2] = 0;
                        updateColumn(fromLeft + 2);
                        fromRight++;
                        angle = 1;
                      }
                      break;

                    case 1:
                      // o . .        . o o
                      // o o .  --->  o o .
                      // . o .        . . .
                      if ((fromRight > 0)
                          && (((active[fromLeft + 1] << 1) & screen[fromLeft + 1]) == 0)
                          && (((active[fromLeft] & (active[fromLeft] << 1)) & screen[fromLeft + 2]) == 0))
                      {
                        active[fromLeft] = (active[fromLeft] & active[fromLeft + 1]);
                        updateColumn(fromLeft);
                        active[fromLeft + 1] = (active[fromLeft + 1] << 1);
                        updateColumn(fromLeft + 1);
                        active[fromLeft + 2] = (active[fromLeft] << 1);
                        updateColumn(fromLeft + 2);
                        fromRight--;
                        krok--;
                        angle = 2;
                      }
                      break;

                    case 2:
                      // . o o        . o .
                      // o o .  --->  . o o
                      // . . .        . . o
                      if ((krok < lcRows)
                          && (((active[fromLeft + 1] >> 1) & screen[fromLeft + 2]) == 0))
                      {
                        active[fromLeft] = 0;
                        updateColumn(fromLeft);
                        //active[fromLeft + 1]
                        active[fromLeft + 2] = (active[fromLeft + 1] >> 1);
                        updateColumn(fromLeft + 2);
                        fromLeft++;
                        krok++;
                        angle = 3;
                      }
                      break;

                    case 3:
                      // . o .        . . .
                      // . o o  --->  . o o
                      // . . o        o o .
                      if ((fromLeft > 0)
                          && ((active[fromLeft + 1] & ((active[fromLeft + 1] >> 1)) & screen[fromLeft - 1]) == 0)
                          && ((active[fromLeft + 1] & screen[fromLeft]) == 0))
                      {
                        active[fromLeft - 1] = (active[fromLeft + 1] & (active[fromLeft + 1] >> 1));
                        updateColumn(fromLeft - 1);
                        active[fromLeft] = active[fromLeft + 1];
                        updateColumn(fromLeft);
                        active[fromLeft + 1] = (active[fromLeft - 1] << 1);
                        updateColumn(fromLeft + 1);
                        fromLeft--;
                        angle = 0;
                      }
                      break;
                  }
                  break;
              }
              playNote('E', 10);
              buttonDelay(200);
            }
          }


          //Restart
          if (digitalRead(start_button) == LOW)
          {
            memset(lc0, 0, sizeof(lc0));
            memset(lc1, 0, sizeof(lc1));
            memset(active, 0, sizeof(active));
            memset(screen, 0, sizeof(screen));
            score = 0;
            allLines = 0;
            figura = 0;
            break;
          }

          for (int colnum = 0; colnum < lcCols; colnum++)
          {

            if ((screen[colnum] & (active[colnum] >> 1)) == 0)
            {
              colCheck++;
            }

            else
            {
              colCheck = 0;
              if (krok == 0)
              {
                started = 0;
              }
            }
          }

          if ((colCheck == lcCols) && (krok < lcRows))
          {
            for (int colnum = 0; colnum < lcCols; colnum++)
            {
              active[colnum] = active[colnum] >> 1;
              updateColumn(colnum);
            }
            //thêm
            switch (figuraNext)
            {
              case 1:
                //"O"
                for (int rownum = 0; rownum <= 8; rownum++)
                {
                  lc.setRow(2, rownum, figuraO[rownum]);
                }
                break;

              case 2:
                //"L"
                for (int rownum = 0; rownum <= 8; rownum++)
                {
                  lc.setRow(2, rownum, figuraL[rownum]);
                }
                break;

              case 3:
                //"J"
                for (int rownum = 0; rownum <= 8; rownum++)
                {
                  lc.setRow(2, rownum, figuraJ[rownum]);
                }
                break;

              case 4:
                //"T"
                for (int rownum = 0; rownum <= 8; rownum++)
                {
                  lc.setRow(2, rownum, figuraT[rownum]);
                }
                break;

              case 5:
                //"I"
                for (int rownum = 0; rownum <= 8; rownum++)
                {
                  lc.setRow(2, rownum, figuraI[rownum]);
                }
                break;

              case 6:
                //"Z"
                for (int rownum = 0; rownum <= 8; rownum++)
                {
                  lc.setRow(2, rownum, figuraZ[rownum]);
                }
                break;

              case 7:
                //"S"
                for (int rownum = 0; rownum <= 8; rownum++)
                {
                  lc.setRow(2, rownum, figuraS[rownum]);
                }
                break;
            }
            //thêm
          }
          else
          {
            break;
          }
          delay(brickDelay);
        }

        for (int colnum = 0; colnum < lcCols; colnum++)
        {
          screen[colnum] = screen[colnum] | (lc0[colnum] << (lcRows / 2));
          screen[colnum] = screen[colnum] | lc1[colnum];
          lc0[colnum] = 0;
          lc1[colnum] = 0;
          active[colnum] = 0;
        }



        currLines = 0;
        for (int rownum = 0; rownum < lcRows; rownum++)
        {
          colCheck = 0;
          for (int colnum = 0; colnum < lcCols; colnum++)
          {
            if (((screen[colnum] >> rownum) & 1) == 1)
            {
              colCheck++;
            }
          }
          if (colCheck == lcCols)
          {
            //Animacja kasowania
            for (int colnum = 0; colnum < lcCols; colnum++)
            {
              tmpCol = ~((int) round(pow(2, rownum)));
              screen[colnum] = screen[colnum] & tmpCol;
              updateColumn(colnum);

              switch (currLines)
              {
                case 0:
                  playNote('b', 20);
                  break;
                case 1:
                  playNote('D', 20);
                  break;
                case 2:
                  playNote('F', 20);
                  break;
                case 3:
                  playNote('A', 20);
                  break;
              }
              delay(30);

              tmpCol = (int) (round(pow(2, rownum)) - 1);
              tmpCol = screen[colnum] & tmpCol;
              screen[colnum] = (screen[colnum] >> (rownum + 1));
              screen[colnum] = (screen[colnum] << rownum);
              screen[colnum] = screen[colnum] | tmpCol;

            }


            for (int colnum = 0; colnum < lcCols; colnum++)
            {
              updateColumn(colnum);
            }
            rownum--;
            currLines++;
            allLines++;
          }
        }

        if (currLines > 0)
        {

          //        score += (int) round(pow(4, currLines - 1));
          score += (int) round(pow(2, currLines - 1));
        }

        showScore(score);
      }
    }
    //    esp8266.println(score);//gửi qua cho ESP
    gameOver();
    // == Game Over ==

  }
}

void copyNumberMatrix(byte number, byte arr[3][8]) {
  const byte (*numberMatrix)[8] = nullptr;

  switch (number) {
    case 0: numberMatrix = zero; break;
    case 1: numberMatrix = one; break;
    case 2: numberMatrix = two; break;
    case 3: numberMatrix = three; break;
    case 4: numberMatrix = four; break;
    case 5: numberMatrix = five; break;
    case 6: numberMatrix = six; break;
    case 7: numberMatrix = seven; break;
    case 8: numberMatrix = eight; break;
    case 9: numberMatrix = nine; break;
  }

  if (numberMatrix != nullptr) {
    for (int i = 0; i < 3; i++) {
      for (int j = 0; j < 8; j++) {
        arr[i][j] = numberMatrix[i][j];
      }
    }
  }
}

byte firstArr[3][8] = {};
byte secondArr[3][8] = {};

void showScore(byte number) {
  byte secondNumber = score % 10;
  byte firstNumber = (score / 10) % 10;
  copyNumberMatrix(firstNumber, firstArr);
  copyNumberMatrix(secondNumber, secondArr);

  for (int i = 0; i < 8; i++) {
    if (i < 3) {
      for (int j = 0; j < 8; j++) {
        lc.setLed(3, i, j, secondArr[i][j]);
      }
    } else if (i > 4) {
      for (int j = 0; j < 8; j++) {
        lc.setLed(3, i, j, firstArr[i - 5][j]);
      }
    }
  }
}

void sendScore(int score) {
  mySerial.print("Score " + String(score) + "\r\n");
}

void gameOver()
{
  playNote('F', 80);
  playNote('A', 60);
  playNote('F', 80);
  playNote('A', 60);

  int full[] =
  {
    B11111111,
    B11111111,
    B11111111,
    B11111111,
    B11111111,
    B11111111,
    B11111111,
    B11111111
  };

  for (int rownum = 0; rownum <= 8; rownum++)
  {
    lc.setColumn(3, rownum, full[rownum]);
    delay(50);

  }
  for (int rownum = 0; rownum <= 8; rownum++)
  {
    lc.setColumn(2, rownum, full[rownum]);
    delay(50);
  }
  for (int rownum = 0; rownum <= 8; rownum++)
  {
    lc.setColumn(1, rownum, full[rownum]);
    delay(50);
  }
  for (int rownum = 0; rownum <= 8; rownum++)
  {
    lc.setColumn(0, rownum, full[rownum]);
    delay(50);
  }
  delay(100);
  //Hiển thị G Over
  int one[] =
  {
    B00001111,
    B00010000,
    B00110000,
    B00110000,
    B00110001,
    B00110000,
    B00010000,
    B00001111
  };

  int two[] =
  {
    B00000000,
    B11000011,
    B11000100,
    B00000100,
    B11100100,
    B11000100,
    B10000100,
    B00000011
  };
  int three[] =
  {
    B00000000,
    B00100101,
    B10100101,
    B10100101,
    B10100101,
    B10100101,
    B10100101,
    B00011001
  };

  int four[] =
  {
    B00000000,
    B11011100,
    B00010100,
    B00010100,
    B10011000,
    B00010100,
    B00010100,
    B11010100
  };

  for (int rownum = 0; rownum < 8; rownum++)
  {
    lc.setRow(3, rownum, one[rownum]);
    lc.setRow(2, rownum, two[rownum]);
    lc.setRow(1, rownum, three[rownum]);
    lc.setRow(0, rownum, four[rownum]);
  }
  sendScore(score);
  delay(2000);
}